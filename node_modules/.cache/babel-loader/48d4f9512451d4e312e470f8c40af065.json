{"ast":null,"code":"var _jsxFileName = \"/Users/peterbak/Documents/game1010/src/widgets/Board.js\",\n    _s = $RefreshSig$();\n\nimport { Box } from '@material-ui/core';\nimport React, { useRef, useLayoutEffect } from 'react';\nimport useStyles from '../style';\nimport * as d3 from 'd3';\nimport { generateStones } from './Stones';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst draw = (div, config, handleGameChange) => {\n  debugger;\n  let s = Math.floor(div.getBoundingClientRect().width / config.grid) || config.size,\n      p = config.padding,\n      width = config.grid * (s + p),\n      height = (config.grid + 5) * (s + p),\n      col = d3.scaleOrdinal().range(config.colors);\n  const board = d3.range(config.grid).map(r => d3.range(config.grid).map(c => ({\n    x: c * (s + p),\n    y: r * (s + p),\n    free: true\n  })));\n  let stones = generateStones(config.stones),\n      drawnStones = [],\n      stoneCodes = {},\n      currentStoneNrs = [],\n      currentStoneStartpost = {\n    x: 0,\n    y: 0\n  },\n      stonesLayed = 0,\n      movingStone = 0;\n\n  const removeCell = cell => {\n    cell.stone.transition().duration(500).attr(\"x\", s / 2).attr(\"y\", s / 2).attr(\"height\", 0).attr(\"width\", 0).remove();\n    cell['stone'] = null;\n    cell.free = true;\n  };\n\n  const checkRowColFull = () => {\n    let fullRow = [],\n        fullColumn = [];\n\n    for (let r = 0; r < config.grid; r++) {\n      let cRow = board[r].every(c => !c.free);\n      let cCol = board.map(b => b[r]).every(c => !c.free);\n\n      if (cRow) {\n        fullRow.push(r);\n      }\n\n      if (cCol) {\n        fullColumn.push(r);\n      }\n    }\n\n    fullRow.forEach(row => {\n      board[row].forEach(cell => {\n        removeCell(cell);\n      });\n    });\n    fullColumn.forEach(col => {\n      board.forEach(row => {\n        let cell = row[col];\n        removeCell(cell);\n      });\n    });\n    return (fullRow.length + fullColumn.length) * config.grid;\n  };\n\n  const snapToGrid = (x, y) => {\n    let pos = {\n      c: Math.max(0, Math.floor(x / (s + p))),\n      r: Math.max(0, Math.floor(y / (s + p)))\n    };\n\n    if (pos.r >= config.grid) {\n      pos.y = currentStoneStartpost.y; //height + s * 2\n\n      pos.x = currentStoneStartpost.x; //(width - s) / 2\n\n      pos.c = pos.r = null;\n    } else {\n      pos.y = Math.min(config.grid - 1, pos.r) * (s + p);\n      pos.x = Math.min(config.grid - 1, pos.c) * (s + p);\n    }\n\n    return pos;\n  };\n\n  const checkPositionFree = (pos, codes) => {\n    let flag = true;\n    codes.forEach(t => {\n      if (pos.c === null || pos.r === null) {\n        flag = false;\n      } else if (t[0] + pos.c >= config.grid || t[0] + pos.c < 0 || t[1] + pos.r >= config.grid || t[1] + pos.r < 0) {\n        flag = false;\n      } else if (board[t[1] + pos.r][t[0] + pos.c].free === false) {\n        flag = false;\n      }\n    });\n    return flag;\n  };\n\n  const setPosition = (pos, val, codes, stn) => {\n    codes.forEach((t, i) => {\n      board[t[1] + pos.r][t[0] + pos.c].free = val;\n      board[t[1] + pos.r][t[0] + pos.c].stone = stn[i];\n    });\n  };\n\n  const moveStone = (x, y, stn) => {\n    stn.forEach(t => t.attr(\"transform\", \"translate(\" + x + \",\" + y + \")\"));\n  };\n\n  let drawnPiecePos = 0;\n\n  const drawStonePieces = (stn, color, index) => {\n    let pieces = [];\n    let stoneWidth = d3.max(stn.map(s => s[0]));\n    let stoneHeight = d3.max(stn.map(s => s[1]));\n    let stonePosY = height - 4 * (s + p);\n    let stonePosX = drawnPiecePos * (s + p);\n\n    if (stonePosX > width - (stoneWidth + 1) * (s + p)) {\n      // stonePosY = height - 2 * (s+p)\n      stonePosX = width - (stoneWidth + 1) * (s + p);\n    }\n\n    let gPieces = svg.append(\"g\");\n    stn.forEach(cell => {\n      let piece = gPieces.append(\"rect\").attr(\"class\", \"stn\").attr(\"x\", cell[0] * (s + p)).attr(\"y\", cell[1] * (s + p)).attr(\"width\", s).attr(\"height\", s).attr(\"rx\", 1).attr(\"ry\", 1).style(\"fill\", col(color)).style(\"fill-opacity\", 0.75).style(\"stroke\", \"#000\").style(\"stroke-width\", 1).attr(\"pointer-events\", \"none\").attr(\"transform\", \"translate(\" + (stonePosX + 2) + \",\" + stonePosY + \")\"); // .call(drag);\n\n      pieces.push(piece);\n    });\n    gPieces.append('rect').attr(\"class\", \"draghandler\").attr(\"stn\", index).attr(\"x\", stonePosX).attr(\"y\", stonePosY).attr(\"width\", (stoneWidth + 1) * (s + p)).attr(\"height\", (stoneHeight + 1) * (s + p)).attr(\"fill-opacity\", 0).attr(\"stroke\", \"none\").call(drag);\n    drawnPiecePos += stoneWidth + 2;\n    return pieces;\n  };\n\n  const drawStone = () => {\n    if (currentStoneNrs.length > 0) {\n      return;\n    }\n\n    stones = generateStones(config.stones);\n    drawnPiecePos = 0;\n\n    for (let i = 0, I = stones.length; i < I; i++) {\n      const stn = stones.shift();\n      stoneCodes[stonesLayed] = stn.stone;\n      let pieces = drawStonePieces(stn.stone, stn.type, stonesLayed);\n      drawnStones.push(pieces);\n      currentStoneNrs.push(stonesLayed);\n      stonesLayed++;\n    }\n  };\n\n  function dragstarted(event, i, n) {\n    movingStone = +d3.select(this).attr(\"stn\");\n    let pos = {\n      x: event.x,\n      y: event.y\n    };\n    let stn = drawnStones[movingStone];\n    let offset = {\n      x: svg.node().getBoundingClientRect().x,\n      y: svg.node().getBoundingClientRect().y\n    };\n    stn.forEach(s => {\n      pos.x = Math.min(pos.x, s.node().getBoundingClientRect().x - offset.x);\n      pos.y = Math.min(pos.y, s.node().getBoundingClientRect().y - offset.y);\n    });\n    currentStoneStartpost = pos;\n\n    if (currentStoneNrs.indexOf(movingStone) < 0) {\n      movingStone = null;\n    }\n  }\n\n  function dragged(event) {\n    if (movingStone === null) {\n      return;\n    }\n\n    let stn = drawnStones[movingStone];\n    let stnCode = stoneCodes[movingStone];\n    let pos = snapToGrid(event.x, event.y - s * 2);\n    moveStone(pos.x, pos.y, stn);\n    let check = checkPositionFree(pos, stnCode);\n    stn.forEach(m => {\n      m.style(\"fill-opacity\", check === false ? 0.25 : 0.75);\n    });\n  }\n\n  function dragended(event) {\n    if (movingStone === null) {\n      return;\n    }\n\n    let stn = drawnStones[movingStone];\n    let stnCode = stoneCodes[movingStone];\n    let pos = snapToGrid(event.x, event.y - s * 2);\n    let check = checkPositionFree(pos, stnCode);\n\n    if (check === true) {\n      setPosition(pos, false, stnCode, stn);\n      d3.select(this).remove();\n      stn.forEach(s => s.style(\"stroke-width\", 0));\n      handleGameChange('points', stnCode.length);\n      currentStoneNrs.splice(currentStoneNrs.indexOf(movingStone), 1);\n      let points = checkRowColFull();\n      setTimeout(() => {\n        handleGameChange('fullrow', points);\n      }, 500);\n      drawStone();\n    } else {\n      pos = snapToGrid(width, height);\n      moveStone(pos.x, pos.y, stn);\n      stn.forEach(m => {\n        m.style(\"fill-opacity\", 0.75);\n      });\n    }\n  }\n\n  const drag = d3.drag().on(\"start\", dragstarted).on(\"drag\", dragged).on(\"end\", dragended);\n  d3.select(div).selectAll('*').remove();\n  const svg = d3.select(div).append(\"svg\").attr(\"width\", width).attr(\"height\", height).append(\"g\").attr(\"transform\", \"translate(\" + p + \",\" + p + \")\");\n  let row = svg.selectAll(\".row\").data(board).enter().append(\"g\").attr(\"class\", \"row\");\n  row.selectAll(\".square\").data(d => d).enter().append(\"rect\").attr(\"class\", \"board\").attr(\"x\", d => d.x).attr(\"y\", d => d.y).attr(\"width\", s).attr(\"height\", s).attr(\"rx\", s / config.size).attr(\"ry\", s / config.size).style(\"fill\", \"#fff\").style(\"stroke\", \"#a2a2a2\");\n  drawStone();\n};\n\nconst Board = ({\n  config,\n  points,\n  handleChange\n}) => {\n  _s();\n\n  const classes = useStyles();\n  const widgetRef = useRef(null);\n\n  const handleGameChange = (key, value) => {\n    handleChange(key, value);\n  };\n\n  useLayoutEffect(() => {\n    if (points > 0) {\n      return;\n    }\n\n    draw(widgetRef.current, config, handleGameChange);\n  });\n  return /*#__PURE__*/_jsxDEV(Box, {\n    className: classes.board,\n    ref: widgetRef\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 267,\n    columnNumber: 12\n  }, this);\n};\n\n_s(Board, \"cFDRHWlqjeUjP2b8ZEl5Vn6bhi8=\", false, function () {\n  return [useStyles];\n});\n\n_c = Board;\nexport default Board;\n\nvar _c;\n\n$RefreshReg$(_c, \"Board\");","map":{"version":3,"sources":["/Users/peterbak/Documents/game1010/src/widgets/Board.js"],"names":["Box","React","useRef","useLayoutEffect","useStyles","d3","generateStones","draw","div","config","handleGameChange","s","Math","floor","getBoundingClientRect","width","grid","size","p","padding","height","col","scaleOrdinal","range","colors","board","map","r","c","x","y","free","stones","drawnStones","stoneCodes","currentStoneNrs","currentStoneStartpost","stonesLayed","movingStone","removeCell","cell","stone","transition","duration","attr","remove","checkRowColFull","fullRow","fullColumn","cRow","every","cCol","b","push","forEach","row","length","snapToGrid","pos","max","min","checkPositionFree","codes","flag","t","setPosition","val","stn","i","moveStone","drawnPiecePos","drawStonePieces","color","index","pieces","stoneWidth","stoneHeight","stonePosY","stonePosX","gPieces","svg","append","piece","style","call","drag","drawStone","I","shift","type","dragstarted","event","n","select","offset","node","indexOf","dragged","stnCode","check","m","dragended","splice","points","setTimeout","on","selectAll","data","enter","d","Board","handleChange","classes","widgetRef","key","value","current"],"mappings":"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","sourcesContent":["import { Box } from '@material-ui/core'\nimport React, {useRef, useLayoutEffect} from 'react'\n\nimport useStyles from '../style';\nimport * as d3 from 'd3';\nimport { generateStones } from './Stones'\n\nconst draw = (div, config, handleGameChange) => {\n    debugger;\n    let s = Math.floor(div.getBoundingClientRect().width / config.grid) || config.size,\n        p=config.padding,\n        width = config.grid * (s + p),\n        height = (config.grid + 5) * (s + p),\n        col = d3.scaleOrdinal().range(config.colors);\n\n    const board = d3.range(config.grid).map((r) => \n        d3.range(config.grid).map((c) => \n            ({\n                x: c * (s + p), \n                y: r * (s + p), \n                free: true \n            })));\n\n    let stones = generateStones(config.stones), \n        drawnStones = [], \n        stoneCodes = {},\n        currentStoneNrs = [],\n        currentStoneStartpost = {x:0, y:0},\n        stonesLayed = 0, \n        movingStone = 0;\n\n    const removeCell = (cell) => {\n        cell.stone.transition().duration(500)\n            .attr(\"x\",s / 2).attr(\"y\", s / 2)\n            .attr(\"height\", 0).attr(\"width\",0).remove();\n        cell['stone'] = null;\n        cell.free = true;\n    }\n\n    const checkRowColFull = () => {\n        let fullRow = [], fullColumn = [];\n        for (let r = 0; r < config.grid; r++){\n            let cRow = board[r].every(c=>!c.free);\n            let cCol = board.map(b => b[r]).every(c=>!c.free);\n            if (cRow) {\n                fullRow.push(r);\n            }\n            if (cCol) {\n                fullColumn.push(r);\n            }\n        }\n        fullRow.forEach(row => {\n            board[row].forEach(cell => {\n                removeCell(cell)\n            })\n        })\n        fullColumn.forEach(col => {\n            board.forEach(row => {\n                let cell = row[col]\n                removeCell(cell);\n            })\n        })\n        return (fullRow.length + fullColumn.length) * config.grid;\n    }\n        \n    const snapToGrid = (x, y) => {\n        let pos = {\n            c: Math.max(0, Math.floor(x / (s + p))),\n            r: Math.max(0, Math.floor(y / (s + p)))\n        }\n        if (pos.r >= config.grid) {\n            pos.y = currentStoneStartpost.y; //height + s * 2\n            pos.x = currentStoneStartpost.x; //(width - s) / 2\n            pos.c = pos.r = null;\n        } else {\n            pos.y = Math.min(config.grid-1, pos.r) * (s + p)\n            pos.x = Math.min(config.grid-1, pos.c) * (s + p)\n        }\n        return pos\n    }\n\n    const checkPositionFree = (pos, codes) => {\n        let flag = true;\n        codes.forEach(t => {\n            if (pos.c===null || pos.r===null){\n                flag = false\n            } else if (t[0]+pos.c >= config.grid || t[0]+pos.c < 0 || t[1]+pos.r >= config.grid || t[1]+pos.r < 0){\n                flag = false\n            } else if (board[t[1]+pos.r][t[0]+pos.c].free===false){\n                flag = false;\n            }\n        })\n        return flag;\n    }\n\n    const setPosition = (pos, val, codes, stn) => {\n        codes.forEach((t,i) => {\n            board[t[1]+pos.r][t[0]+pos.c].free = val;\n            board[t[1]+pos.r][t[0]+pos.c].stone = stn[i];\n        });\n    }\n\n    const moveStone = (x, y, stn) => {\n        stn.forEach(t => t.attr(\"transform\",\"translate(\"+(x)+\",\"+(y)+\")\"));\n    }\n\n    let drawnPiecePos = 0;\n    const drawStonePieces  = (stn, color, index) => {\n        let pieces = []\n        let stoneWidth = d3.max(stn.map(s => s[0]));\n        let stoneHeight = d3.max(stn.map(s => s[1]));\n        let stonePosY = height - 4 * (s+p)\n        let stonePosX = drawnPiecePos * (s + p);\n        if (stonePosX > width - (stoneWidth+1) * (s + p)){\n            // stonePosY = height - 2 * (s+p)\n            stonePosX = width - (stoneWidth+1) * (s + p)\n        }\n        let gPieces = svg.append(\"g\")\n        stn.forEach((cell) => {\n            let piece = gPieces.append(\"rect\")\n                .attr(\"class\",\"stn\")\n                .attr(\"x\", cell[0] * (s + p) )\n                .attr(\"y\", cell[1] * (s + p))\n                .attr(\"width\", s )\n                .attr(\"height\", s )\n                .attr(\"rx\", 1)\n                .attr(\"ry\", 1)\n                .style(\"fill\", col(color))\n                .style(\"fill-opacity\", 0.75)\n                .style(\"stroke\", \"#000\")\n                .style(\"stroke-width\", 1)\n                .attr(\"pointer-events\", \"none\")\n                .attr(\"transform\",\"translate(\"+(stonePosX + 2)+\",\"+(stonePosY)+\")\")\n                // .call(drag);\n            pieces.push(piece)\n        })\n        gPieces.append('rect')\n            .attr(\"class\", \"draghandler\")\n            .attr(\"stn\", index)\n            .attr(\"x\", stonePosX)\n            .attr(\"y\", stonePosY)\n            .attr(\"width\", (stoneWidth + 1)  * (s + p))\n            .attr(\"height\", (stoneHeight + 1) * (s + p))\n            .attr(\"fill-opacity\", 0)\n            .attr(\"stroke\", \"none\")\n            .call(drag);\n        drawnPiecePos += stoneWidth + 2;\n        return pieces;\n    }\n \n    const drawStone = () => {\n        if (currentStoneNrs.length>0){ return }\n\n        stones = generateStones(config.stones);\n        drawnPiecePos = 0;\n        for (let i = 0, I = stones.length; i < I; i++){\n            const stn = stones.shift();\n            stoneCodes[stonesLayed] = stn.stone;\n            let pieces = drawStonePieces(stn.stone, stn.type, stonesLayed);\n            drawnStones.push(pieces);\n            currentStoneNrs.push(stonesLayed);\n            stonesLayed++;\n        }\n    }\n\n    function dragstarted(event, i , n) {\n        movingStone = +d3.select(this).attr(\"stn\");\n        let pos = {x: event.x, y: event.y}\n        let stn = drawnStones[movingStone];\n        let offset = {x: svg.node().getBoundingClientRect().x, \n            y: svg.node().getBoundingClientRect().y};\n        stn.forEach(s => {\n            pos.x = Math.min(pos.x, s.node().getBoundingClientRect().x - offset.x)\n            pos.y = Math.min(pos.y, s.node().getBoundingClientRect().y - offset.y) \n        });\n        currentStoneStartpost = pos;\n        if (currentStoneNrs.indexOf(movingStone) < 0){\n            movingStone = null;\n        }\n    }\n    \n    function dragged(event) {\n        if (movingStone===null){return;}\n        let stn = drawnStones[movingStone]\n        let stnCode = stoneCodes[movingStone]\n        let pos = snapToGrid(event.x, event.y - (s * 2));\n        moveStone(pos.x, pos.y, stn)\n        let check  = checkPositionFree(pos, stnCode);\n        stn.forEach(m => {\n            m.style(\"fill-opacity\", check===false ? 0.25 : 0.75)\n        });\n    }\n    \n    function dragended(event) {\n        if (movingStone===null){return;}\n        let stn = drawnStones[movingStone]\n        let stnCode = stoneCodes[movingStone]\n        let pos = snapToGrid(event.x, event.y - (s * 2));\n        let check  = checkPositionFree(pos, stnCode);\n\n        if (check===true){\n            setPosition(pos, false, stnCode, stn)\n            d3.select(this).remove();\n            stn.forEach(s => s.style(\"stroke-width\", 0))\n            handleGameChange('points', stnCode.length);\n            currentStoneNrs.splice(currentStoneNrs.indexOf(movingStone), 1);\n            let points = checkRowColFull();\n            setTimeout(()=>{handleGameChange('fullrow', points)}, 500);\n            drawStone();\n        } else {\n            pos = snapToGrid(width, height);\n            moveStone(pos.x, pos.y, stn);\n            stn.forEach(m => {\n                m.style(\"fill-opacity\", 0.75)\n            });\n        }\n    }\n    \n    const drag = d3.drag()\n          .on(\"start\", dragstarted)\n          .on(\"drag\", dragged)\n          .on(\"end\", dragended);\n\n    d3.select(div).selectAll('*').remove();\n\n    const svg = d3.select(div).append(\"svg\")\n        .attr(\"width\", width)\n        .attr(\"height\", height)\n        .append(\"g\")\n        .attr(\"transform\",\"translate(\"+p+\",\"+p+\")\");\n\n    let row = svg.selectAll(\".row\")\n        .data(board)\n        .enter().append(\"g\")\n        .attr(\"class\", \"row\");\n\n    row.selectAll(\".square\")\n        .data((d) => d)\n        .enter().append(\"rect\")\n        .attr(\"class\",\"board\")\n        .attr(\"x\", (d) => d.x )\n        .attr(\"y\", (d) => d.y )\n        .attr(\"width\", s )\n        .attr(\"height\", s )\n        .attr(\"rx\", s/config.size)\n        .attr(\"ry\", s/config.size)\n        .style(\"fill\", \"#fff\")\n        .style(\"stroke\", \"#a2a2a2\");\n\n    drawStone();\n    \n}\n\nconst Board = ({config, points, handleChange}) => {\n    const classes = useStyles();\n    const widgetRef = useRef(null);\n\n    const handleGameChange = (key, value) => {\n        handleChange(key, value);\n    }\n\n    useLayoutEffect(() => {\n        if (points > 0){ return; }\n        draw(widgetRef.current, config, handleGameChange);\n    });\n\n    return <Box className={classes.board} ref={widgetRef}></Box>\n\n}\n\nexport default Board;"]},"metadata":{},"sourceType":"module"}